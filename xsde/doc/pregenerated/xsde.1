.\" Process this file with
.\" groff -man -Tascii xsde.1
.\"
.TH XSD/e 1 "January 2024" "XSD/e 3.4.0-b.1"
.SH NAME
xsde \- W3C XML Schema to C++ Compiler for Embedded Systems
.\"
.\"
.\"
.\"--------------------------------------------------------------------
.SH SYNOPSIS
.\"--------------------------------------------------------------------
.B xsde
.I command
.B [
.I options
.B ]
.I file
.B [
.I file
.B ...]
.in
.B xsde help
.B [
.I command
.B ]
.in
.B xsde version
.\"
.\"
.\"
.\"--------------------------------------------------------------------
.SH DESCRIPTION
.\"--------------------------------------------------------------------
.B xsde
generates vocabulary-specific, statically-typed C++ mapping from W3C XML
Schema definitions. Particular mapping to produce is selected by a
.IR command .
Each mapping has a number of mapping-specific
.I options
that should appear, if any, after the
.IR command .
Input files should be W3C XML Schema definitions. The exact set of the
generated files depends on the selected mapping and options.
.\"
.\"
.\"
.\"--------------------------------------------------------------------
.SH COMMANDS
.\"--------------------------------------------------------------------
.IP \fBcxx-hybrid\fR
Generate the Embedded C++/Hybrid mapping. For each input file in the
form
.B name.xsd
the following C++ files are generated:
.B name.hxx
(object model header file),
.B name.ixx
(object model inline file, generated only if the
.B --generate-inline
option is specified),
.B name.cxx
(object model source file), and
.B name-fwd.hxx
(object model forward declaration file, generated only if the
.B --generate-forward
option is specified).

If the
.B --generate-parser
option is specified, the Embedded C++/Parser mapping is invoked and the
.BR name-pskel.hxx ,
.BR name-pskel.ixx ,
and
.B name-pskel.cxx
parser skeleton files are generated, as described below. Additionally,
the following parser implementation files are generated:
.B name-pimpl.hxx
(parser implementation header file) and
.B name-pimpl.cxx
(parser implementation source file).

If the
.B --generate-serializer
option is specified, the Embedded C++/Serializer mapping is invoked and the
.BR name-sskel.hxx ,
.BR name-sskel.ixx ,
and
.B name-sskel.cxx
serializer skeleton files are generated, as described below. Additionally,
the following serializer implementation files are generated:
.B name-simpl.hxx
(serializer implementation header file) and
.B name-simpl.cxx
(serializer implementation source file).

.IP \fBcxx-parser\fR
Generate the Embedded C++/Parser mapping. For each input file in the form
.B name.xsd
the following C++ files are generated:
.B name-pskel.hxx
(parser skeleton header file),
.B name-pskel.ixx
(parser skeleton inline file, generated only if the
.B --generate-inline
option is specified), and
.B name-pskel.cxx
(parser skeleton source file). If the
.B --generate-noop-impl
or
.B --generate-print-impl
option is specified, the following additional sample implementation files
are generated:
.B name-pimpl.hxx
(parser implementation header file) and
.B name-pimpl.cxx
(parser implementation source file). If the
.B --generate-test-driver
option is specified, the additional
.B name-pdriver.cxx
test driver file is generated.

.IP \fBcxx-parser\fR
Generate the Embedded C++/Serializer mapping. For each input file in the form
.B name.xsd
the following C++ files are generated:
.B name-sskel.hxx
(serializer skeleton header file),
.B name-sskel.ixx
(serializer skeleton inline file, generated only if the
.B --generate-inline
option is specified), and
.B name-sskel.cxx
(serializer skeleton source file). If the
.B --generate-empty-impl
option is specified, the following additional sample implementation files
are generated:
.B name-simpl.hxx
(serializer implementation header file) and
.B name-simpl.cxx
(serializer implementation source file). If the
.B --generate-test-driver
option is specified, the additional
.B name-sdriver.cxx
test driver file is generated.

.IP \fBhelp\fR
Print usage information and exit. Use
.PP
.RS
.RS 3
.B xsde help
.I command
.RE
.PP
for command-specific help.
.RE
.IP \fBversion\fR
Print version and exit.
.\"--------------------------------------------------------------------
.SH OPTIONS
.\"--------------------------------------------------------------------
Command-specific
.IR options ,
if any, should appear after the corresponding
.IR command .

.\"
.\" Common options.
.\"
.SS common options
.IP "\fB--output-dir\fR \fIdir\fR"
Write generated files to \fIdir\fR instead of the current directory\.
.IP "\fB--char-encoding\fR \fIenc\fR"
Specify the application character encoding\. Valid values are \fButf8\fR
(default) and \fBiso8859-1\fR\. Note that this encoding is not the same as the
XML document encoding that is being parsed or serialized\. Rather, it is the
encoding that is used inside the application\. When an XML document is parsed,
the character data is automatically converted to the application encoding\.
Similarly, when an XML document is serialized, the data in the application
encoding is automatically converted to the resulting document encoding\.
.IP "\fB--no-stl\fR"
Generate code that does not use the C++ Standard Template Library (STL)\.
.IP "\fB--no-iostream\fR"
Generate code that does not use the C++ standard input/output stream library
(iostream)\.
.IP "\fB--no-exceptions\fR"
Generate code that does not use C++ exceptions\.
.IP "\fB--no-long-long\fR"
Generate code that does not use the \fBlong long\fR and \fBunsigned long
long\fR types\. The 64 bit \fBlong\fR and \fBunsignedLong\fR built-in XML
Schema types are then mapped to \fBlong\fR and \fBunsigned long\fR\.
.IP "\fB--custom-allocator\fR"
Generate code that performs memory management using custom allocator functions
provided by your application instead of the standard operator \fBnew\fR and
\fBdelete\fR\.
.IP "\fB--generate-inline\fR"
Generate simple functions inline\. This option triggers creation of the inline
file\.
.IP "\fB--suppress-reset\fR"
Suppress the generation of parser/serializer reset code\. Reset support allows
you to reuse parsers/serializers after an error\.
.IP "\fB--generate-xml-schema\fR"
Generate a C++ header files as if the schema being compiled defines the XML
Schema namespace\. For the C++/Parser mapping, the resulting file will contain
definitions for all the parser skeletons and implementations corresponding to
the XML Schema built-in types\. For the C++/Serializer mapping, the resulting
file will contain definitions for all the serializer skeletons and
implementations corresponding to the XML Schema built-in types\. For the
C++/Hybrid mapping, in addition the the above, a third header file will
contain definitions for all the object model types corresponding to the XML
Schema built-in types\.

The schema file provided to the compiler need not exist and is only used to
derive the name of the resulting header file\. Use the
\fB--extern-xml-schema\fR option to include this file in the generated files
for other schemas\.
.IP "\fB--extern-xml-schema\fR \fIfile\fR"
Include a header file derived from \fIfile\fR instead of generating the XML
Schema namespace mapping inline\. The provided file need not exist and is only
used to derive the name of the included header file\. Use the
\fB--generate-xml-schema\fR option to generate this header file\.
.IP "\fB--namespace-map\fR \fIxns\fR=\fIcns\fR"
Map XML Schema namespace \fIxns\fR to C++ namespace \fIcns\fR\. Repeat this
option to specify mapping for more than one XML Schema namespace\. For
example, the following option:

\fB--namespace-map http://example\.com/foo/bar=foo::bar\fR

Will map the \fBhttp://example\.com/foo/bar\fR XML Schema namespace to the
\fBfoo::bar\fR C++ namespace\.
.IP "\fB--namespace-regex\fR \fIregex\fR"
Add \fIregex\fR to the list of regular expressions used to translate XML
Schema namespace names to C++ namespace names\. \fIregex\fR is a Perl-like
regular expression in the form
\fB/\fR\fIpattern\fR\fB/\fR\fIreplacement\fR\fB/\fR\fR\. Any character can be
used as a delimiter instead of '\fB/\fR'\. Escaping of the delimiter character
in \fIpattern\fR or \fIreplacement\fR is not supported\.

All the regular expressions are pushed into a stack with the last specified
expression considered first\. The first match that succeeds is used\. Regular
expressions are applied to a string in the form

\fIfilename\fR \fInamespace\fR\fR

For example, if you have file \fBhello\.xsd\fR with namespace
\fBhttp://example\.com/hello\fR and you run \fBxsd\fR on this file, then the
string in question will be:

\fBhello\.xsd\. http://example\.com/hello\fR

For the built-in XML Schema namespace the string is:

\fBXMLSchema\.xsd http://www\.w3\.org/2001/XMLSchema\fR

The following three steps are performed for each regular expression until the
match is found:

1\. The expression is applied and if the result is empty the next expression
is considered\.

2\. All '\fB/\fR' are replaced with '\fB::\fR'\.

3\. The result is verified to be a valid C++ scope name (e\.g\.,
\fBfoo::bar\fR)\. If this test succeeds, the result is used as a C++ namespace
name\.

As an example, the following expression maps XML  Schema namespaces in the
form \fBhttp://example\.com/foo/bar\fR to C++ namespaces in the form
\fBfoo::bar\fR:

\fB%\.* http://example\.com/(\.+)%$1%\fR

See also the REGEX AND SHELL QUOTING section below\.
.IP "\fB--namespace-regex-trace\fR"
Trace the process of applying regular expressions specified with the
\fB--namespace-regex\fR option\. Use this option to find out why your regular
expressions don't do what you expected them to do\.
.IP "\fB--reserved-name\fR \fIn\fR[=\fIr\fR]"
Add name \fIn\fR to the list of names that should not be used as identifiers\.
The name can optionally be followed by \fB=\fR and the replacement name
\fIr\fR that should be used instead\. All the C++ keywords are already in this
list\.
.IP "\fB--include-with-brackets\fR"
Use angle brackets (<>) instead of quotes ("") in generated \fB#include\fR
directives\.
.IP "\fB--include-prefix\fR \fIprefix\fR"
Add \fIprefix\fR to generated \fB#include\fR directive paths\.

For example, if you had the following import element in your schema

\fB<import namespace="\.\.\." schemaLocation="base\.xsd"/>\fR

and compiled this fragment with \fB--include-prefix schemas/\fR, then the
include directive in the generated code would be:

\fB#include "schemas/base\.hxx"\fR
.IP "\fB--include-regex\fR \fIregex\fR"
Add \fIregex\fR to the list of regular expressions used to transform
\fB#include\fR directive paths\. \fIregex\fR is a Perl-like regular expression
in the form \fB/\fR\fIpattern\fR\fB/\fR\fIreplacement\fR\fB/\fR\fR\. Any
character can be used as a delimiter instead of '\fB/\fR'\. Escaping of the
delimiter character in \fIpattern\fR or \fIreplacement\fR is not supported\.

All the regular expressions are pushed into a stack with the last specified
expression considered first\. The first match that succeeds is used\.

As an example, the following expression transforms paths in the form
\fBschemas/foo/bar\fR to paths in the form \fBgenerated/foo/bar\fR:

\fB%schemas/(\.+)%generated/$1%\fR

See also the REGEX AND SHELL QUOTING section below\.
.IP "\fB--include-regex-trace\fR"
Trace the process of applying regular expressions specified with the
\fB--include-regex\fR option\. Use this option to find out why your regular
expressions don't do what you expected them to do\.
.IP "\fB--guard-prefix\fR \fIprefix\fR"
Add \fIprefix\fR to generated header inclusion guards\. The prefix is
transformed to upper case and characters that are illegal in a preprocessor
macro name are replaced with underscores\. If this option is not specified
then the directory part of the input schema file is used as a prefix\.
.IP "\fB--hxx-suffix\fR \fIsuffix\fR"
Use the provided \fIsuffix\fR instead of the default \fB\.hxx\fR to construct
the name of the header file\. Note that this suffix is also used to construct
names of header files corresponding to included/imported schemas\.
.IP "\fB--ixx-suffix\fR \fIsuffix\fR"
Use the provided \fIsuffix\fR instead of the default \fB\.ixx\fR to construct
the name of the inline file\.
.IP "\fB--cxx-suffix\fR \fIsuffix\fR"
Use the provided \fIsuffix\fR instead of the default \fB\.cxx\fR to construct
the name of the source file\.
.IP "\fB--fwd-suffix\fR \fIsuffix\fR"
Use the provided \fIsuffix\fR instead of the default \fB-fwd\.hxx\fR to
construct the name of the forward declaration file\.
.IP "\fB--hxx-regex\fR \fIregex\fR"
Use the provided expression to construct the name of the header file\.
\fIregex\fR is a Perl-like regular expression in the form
\fB/\fR\fIpattern\fR\fB/\fR\fIreplacement\fR\fB/\fR\fR\. Note that this
expression is also used to construct names of header files corresponding to
included/imported schemas\.

For the C++/Hybrid mapping, the \fIregex\fR argument can be optionally
prefixed with a file key in the form \fIkey\fR=\fIregex\fR\fR\. The valid
values for \fIkey\fR are \fBpskel\fR (parser skeleton files), \fBpimpl\fR
(parser implementation files), \fBsskel\fR (serializer skeleton files),
\fBsimpl\fR (serializer implementation files), and \fB*\fR (all files)\. If
\fIkey\fR is empty or not present then the expression is used for the object
model files only\.

See also the REGEX AND SHELL QUOTING section below\.
.IP "\fB--ixx-regex\fR \fIregex\fR"
Use the provided expression to construct the name of the inline file\.
\fIregex\fR is a Perl-like regular expression in the form
\fB/\fR\fIpattern\fR\fB/\fR\fIreplacement\fR\fB/\fR\fR\. For the C++/Hybrid
mapping, the \fIregex\fR argument can be optionally prefixed with a file key\.
See the \fB--hxx-regex\fR option for details\. See also the REGEX AND SHELL
QUOTING section below\.
.IP "\fB--cxx-regex\fR \fIregex\fR"
Use the provided expression to construct the name of the source file\.
\fIregex\fR is a Perl-like regular expression in the form
\fB/\fR\fIpattern\fR\fB/\fR\fIreplacement\fR\fB/\fR\fR\. For the C++/Hybrid
mapping, the \fIregex\fR argument can be optionally prefixed with a file key\.
See the \fB--hxx-regex\fR option for details\. See also the REGEX AND SHELL
QUOTING section below\.
.IP "\fB--fwd-regex\fR \fIregex\fR"
Use the provided expression to construct the name of the forward declaration
file\. \fIregex\fR is a Perl-like regular expression in the form
\fB/\fR\fIpattern\fR\fB/\fR\fIreplacement\fR\fB/\fR\fR\. See also the REGEX
AND SHELL QUOTING section below\.
.IP "\fB--hxx-prologue\fR \fItext\fR"
Insert \fItext\fR at the beginning of the header file\.

For the C++/Hybrid mapping, the \fItext\fR argument can be optionally prefixed
with a file key in the form \fIkey\fR=\fItext\fR\fR\. The valid values for
\fIkey\fR are \fBpskel\fR (parser skeleton files), \fBpimpl\fR (parser
implementation files), \fBsskel\fR (serializer skeleton files), \fBsimpl\fR
(serializer implementation files), and \fB*\fR (all files)\. If \fIkey\fR is
empty or not present then the text is used for the object model files only\.
.IP "\fB--ixx-prologue\fR \fItext\fR"
Insert \fItext\fR at the beginning of the inline file\. For the C++/Hybrid
mapping, the \fItext\fR argument can be optionally prefixed with a file key\.
See the \fB--hxx-prologue\fR option for details\.
.IP "\fB--cxx-prologue\fR \fItext\fR"
Insert \fItext\fR at the beginning of the source file\. For the C++/Hybrid
mapping, the \fItext\fR argument can be optionally prefixed with a file key\.
See the \fB--hxx-prologue\fR option for details\.
.IP "\fB--fwd-prologue\fR \fItext\fR"
Insert \fItext\fR at the beginning of the forward declaration file\.
.IP "\fB--prologue\fR \fItext\fR"
Insert \fItext\fR at the beginning of each generated file for which there is
no file-specific prologue\. For the C++/Hybrid mapping, the \fItext\fR
argument can be optionally prefixed with a file key\. See the
\fB--hxx-prologue\fR option for details\.
.IP "\fB--hxx-epilogue\fR \fItext\fR"
Insert \fItext\fR at the end of the header file\. For the C++/Hybrid mapping,
the \fItext\fR argument can be optionally prefixed with a file key\. See the
\fB--hxx-prologue\fR option for details\.
.IP "\fB--ixx-epilogue\fR \fItext\fR"
Insert \fItext\fR at the end of the inline file\. For the C++/Hybrid mapping,
the \fItext\fR argument can be optionally prefixed with a file key\. See the
\fB--hxx-prologue\fR option for details\.
.IP "\fB--cxx-epilogue\fR \fItext\fR"
Insert \fItext\fR at the end of the source file\. For the C++/Hybrid mapping,
the \fItext\fR argument can be optionally prefixed with a file key\. See the
\fB--hxx-prologue\fR option for details\.
.IP "\fB--fwd-epilogue\fR \fItext\fR"
Insert \fItext\fR at the end of the forward declaration file\.
.IP "\fB--epilogue\fR \fItext\fR"
Insert \fItext\fR at the end of each generated file for which there is no
file-specific epilogue\. For the C++/Hybrid mapping, the \fItext\fR argument
can be optionally prefixed with a file key\. See the \fB--hxx-prologue\fR
option for details\.
.IP "\fB--hxx-prologue-file\fR \fIfile\fR"
Insert the content of the \fIfile\fR at the beginning of the header file\.

For the C++/Hybrid mapping, the \fIfile\fR argument can be optionally prefixed
with a file key in the form \fIkey\fR=\fIfile\fR\fR\. The valid values for
\fIkey\fR are \fBpskel\fR (parser skeleton files), \fBpimpl\fR (parser
implementation files), \fBsskel\fR (serializer skeleton files), \fBsimpl\fR
(serializer implementation files), and \fB*\fR (all files)\. If \fIkey\fR is
empty or not present then the file is used for the object model files only\.
.IP "\fB--ixx-prologue-file\fR \fIfile\fR"
Insert the content of the \fIfile\fR at the beginning of the inline file\. For
the C++/Hybrid mapping, the \fIfile\fR argument can be optionally prefixed
with a file key\. See the \fB--hxx-prologue-file\fR option for details\.
.IP "\fB--cxx-prologue-file\fR \fIfile\fR"
Insert the content of the \fIfile\fR at the beginning of the source file\. For
the C++/Hybrid mapping, the \fIfile\fR argument can be optionally prefixed
with a file key\. See the \fB--hxx-prologue-file\fR option for details\.
.IP "\fB--fwd-prologue-file\fR \fIfile\fR"
Insert the content of the \fIfile\fR at the beginning of the forward
declaration file\.
.IP "\fB--prologue-file\fR \fIfile\fR"
Insert the content of the \fIfile\fR at the beginning of each generated file
for which there is no file-specific prologue file\. For the C++/Hybrid
mapping, the \fIfile\fR argument can be optionally prefixed with a file key\.
See the \fB--hxx-prologue-file\fR option for details\.
.IP "\fB--hxx-epilogue-file\fR \fIfile\fR"
Insert the content of the \fIfile\fR at the end of the header file\. For the
C++/Hybrid mapping, the \fIfile\fR argument can be optionally prefixed with a
file key\. See the \fB--hxx-prologue-file\fR option for details\.
.IP "\fB--ixx-epilogue-file\fR \fIfile\fR"
Insert the content of the \fIfile\fR at the end of the inline file\. For the
C++/Hybrid mapping, the \fIfile\fR argument can be optionally prefixed with a
file key\. See the \fB--hxx-prologue-file\fR option for details\.
.IP "\fB--cxx-epilogue-file\fR \fIfile\fR"
Insert the content of the \fIfile\fR at the end of the source file\. For the
C++/Hybrid mapping, the \fIfile\fR argument can be optionally prefixed with a
file key\. See the \fB--hxx-prologue-file\fR option for details\.
.IP "\fB--fwd-epilogue-file\fR \fIfile\fR"
Insert the content of the \fIfile\fR at the end of the forward declaration
file\.
.IP "\fB--epilogue-file\fR \fIfile\fR"
Insert the content of the \fIfile\fR at the end of each generated file for
which there is no file-specific epilogue file\. For the C++/Hybrid mapping,
the \fIfile\fR argument can be optionally prefixed with a file key\. See the
\fB--hxx-prologue-file\fR option for details\.
.IP "\fB--disable-warning\fR \fIwarn\fR"
Disable printing warning with id \fIwarn\fR\. If \fBall\fR is specified for
the warning id then all warnings are disabled\.
.IP "\fB--options-file\fR \fIfile\fR"
Read additional options from \fIfile\fR\. Each option should appearing on a
separate line optionally followed by space and an option value\. Empty lines
and lines starting with \fB#\fR are ignored\. Option values can be enclosed in
double (\fB"\fR) or single (\fB'\fR) quotes  to preserve leading and trailing
whitespaces as well as to specify empty values\. If the value itself contains
trailing or leading quotes, enclose it with an extra pair of quotes, for
example \fB'"x"'\fR\. Non-leading and non-trailing quotes are interpreted as
being part of the option value\.

The semantics of providing options in a file is equivalent to providing the
same set of options in the same order on the command line at the point where
the \fB--options-file\fR option is specified except that the shell escaping
and quoting is not required\. You can repeat this option to specify more than
one options file\.
.IP "\fB--show-sloc\fR"
Show the number of generated physical source lines of code (SLOC)\.
.IP "\fB--sloc-limit\fR \fInum\fR"
Check that the number of generated physical source lines of code (SLOC) does
not exceed \fInum\fR\.
.IP "\fB--proprietary-license\fR"
Indicate that the generated code is licensed under a proprietary license
instead of the GPL\.
.IP "\fB--preserve-anonymous\fR"
Preserve anonymous types\. By default anonymous types are automatically named
with names derived from the enclosing elements/attributes\. Because mappings
implemented by this compiler require all types to be named, this option is
only useful if you want to make sure your schemas don't have anonymous types\.
.IP "\fB--show-anonymous\fR"
Show elements and attributes that are of anonymous types\. This option only
makes sense together with the \fB--preserve-anonymous\fR option\.
.IP "\fB--anonymous-regex\fR \fIregex\fR"
Add \fIregex\fR to the list of regular expressions used to derive names for
anonymous types from the enclosing attributes/elements\. \fIregex\fR is a
Perl-like regular expression in the form
\fB/\fR\fIpattern\fR\fB/\fR\fIreplacement\fR\fB/\fR\fR\. Any character can be
used as a delimiter instead of '\fB/\fR'\. Escaping of the delimiter character
in \fIpattern\fR or \fIreplacement\fR is not supported\.

All the regular expressions are pushed into a stack with the last specified
expression considered first\. The first match that succeeds is used\. Regular
expressions are applied to a string in the form

\fIfilename\fR \fInamespace\fR \fIxpath\fR\fR

For instance:

\fBhello\.xsd http://example\.com/hello element\fR

\fBhello\.xsd http://example\.com/hello type/element\fR

As an example, the following expression makes all the derived names start with
capital letters\. This could be useful when your naming convention requires
type names to start with capital letters:

\fB%\.* \.* (\.+/)*(\.+)%\eu$2%\fR

See also the REGEX AND SHELL QUOTING section below\.
.IP "\fB--anonymous-regex-trace\fR"
Trace the process of applying regular expressions specified with the
\fB--anonymous-regex\fR option\. Use this option to find out why your regular
expressions don't do what you expected them to do\.
.IP "\fB--location-map\fR \fIol\fR=\fInl\fR"
Map the original schema location \fIol\fR that is specified in the XML Schema
include or import elements to new schema location \fInl\fR\. Repeat this
option to map more than one schema location\. For example, the following
option maps the \fBhttp://example\.com/foo\.xsd\fR URL to the \fBfoo\.xsd\fR
local file\.

\fB--location-map http://example\.com/foo\.xsd=foo\.xsd\fR
.IP "\fB--location-regex\fR \fIregex\fR"
Add \fIregex\fR to the list of regular expressions used to map schema
locations that are specified in the XML Schema include or import elements\.
\fIregex\fR is a Perl-like regular expression in the form
\fB/\fR\fIpattern\fR\fB/\fR\fIreplacement\fR\fB/\fR\fR\. Any character can be
used as a delimiter instead of '\fB/\fR'\. Escaping of the delimiter character
in \fIpattern\fR or \fIreplacement\fR is not supported\. All the regular
expressions are pushed into a stack with the last specified expression
considered first\. The first match that succeeds is used\.

For example, the following expression maps URL locations in the form
\fBhttp://example\.com/foo/bar\.xsd\fR to local files in the form
\fBbar\.xsd\fR:

\fB%http://\.+/(\.+)%$1%\fR

See also the REGEX AND SHELL QUOTING section below\.
.IP "\fB--location-regex-trace\fR"
Trace the process of applying regular expressions specified with the
\fB--location-regex\fR option\. Use this option to find out why your regular
expressions don't do what you expected them to do\.
.IP "\fB--file-per-type\fR"
Generate a separate set of C++ files for each type defined in XML Schema\.
Note that in this mode you only need to compile the root schema(s) and the
code will be generated for all included and imported schemas\. This
compilation mode is primarily useful when some of your schemas cannot be
compiled separately or have cyclic dependencies which involve type
inheritance\. Other options related to this mode are: \fB--type-file-regex\fR,
\fB--schema-file-regex\fR, \fB--fat-type-file\fR, and \fB--file-list\fR\.
.IP "\fB--type-file-regex\fR \fIregex\fR"
Add \fIregex\fR to the list of regular expressions used to translate type
names to file names when the \fB--file-per-type\fR option is specified\.
\fIregex\fR is a Perl-like regular expression in the form
\fB/\fR\fIpattern\fR\fB/\fR\fIreplacement\fR\fB/\fR\fR\. Any character can be
used as a delimiter instead of '\fB/\fR'\. Escaping of the delimiter character
in \fIpattern\fR or \fIreplacement\fR is not supported\. All the regular
expressions are pushed into a stack with the last specified expression
considered first\. The first match that succeeds is used\. Regular expressions
are applied to a string in the form

\fInamespace\fR \fItype-name\fR\fR

For example, the following expression maps type \fBfoo\fR that is defined in
the \fBhttp://example\.com/bar\fR namespace to file name \fBbar-foo\fR:

\fB%http://example\.com/(\.+) (\.+)%$1-$2%\fR

See also the REGEX AND SHELL QUOTING section below\.
.IP "\fB--type-file-regex-trace\fR"
Trace the process of applying regular expressions specified with the
\fB--type-file-regex\fR option\. Use this option to find out why your regular
expressions don't do what you expected them to do\.
.IP "\fB--schema-file-regex\fR \fIregex\fR"
Add \fIregex\fR to the list of regular expressions used to translate schema
file names when the \fB--file-per-type\fR option is specified\. \fIregex\fR is
a Perl-like regular expression in the form
\fB/\fR\fIpattern\fR\fB/\fR\fIreplacement\fR\fB/\fR\fR\. Any character can be
used as a delimiter instead of '\fB/\fR'\. Escaping of the delimiter character
in \fIpattern\fR or \fIreplacement\fR is not supported\. All the regular
expressions are pushed into a stack with the last specified expression
considered first\. The first match that succeeds is used\. Regular Expressions
are applied to the absolute filesystem path of a schema file and the result,
including the directory part, if any, is used to derive the \fB#include\fR
directive paths as well as the generated C++ file paths\. This option, along
with \fB--type-file-regex\fR are primarily useful to place the generated files
into subdirectories or to resolve file name conflicts\.

For example, the following expression maps schema files in the
\fBfoo/1\.0\.0/\fR subdirectory to the files in the \fBfoo/\fR subdirectory\.
As a result, the \fB#include\fR directive paths for such schemas will be in
the \fBfoo/schema\.hxx\fR form and the generated C++ files will be placed into
the \fBfoo/\fR subdirectory:

\fB%\.*/foo/1\.0\.0/(\.+)%foo/$1%\fR

See also the REGEX AND SHELL QUOTING section below\.
.IP "\fB--schema-file-regex-trace\fR"
Trace the process of applying regular expressions specified with the
\fB--schema-file-regex\fR option\. Use this option to find out why your
regular expressions don't do what you expected them to do\.
.IP "\fB--fat-type-file\fR"
Generate code corresponding to global elements into type files instead of
schema files when the \fB--type-file-regex\fR option is specified\. This
option is primarily useful when trying to minimize the amount of object code
that is linked to an executable by packaging compiled generated code into a
static (archive) library\.
.IP "\fB--file-list\fR \fIfile\fR"
Write a list of generated C++ files to \fIfile\fR\. This option is primarily
useful in the file-per-type compilation mode (\fB--file-per-type\fR) to create
a list of generated C++ files, for example, as a makefile fragment\.
.IP "\fB--file-list-prologue\fR \fItext\fR"
Insert \fItext\fR at the beginning of the file list\. As a convenience, all
occurrences of the \fB\en\fR character sequence in \fItext\fR are replaced
with new lines\. This option can, for example, be used to assign the generated
file list to a makefile variable\.
.IP "\fB--file-list-epilogue\fR \fItext\fR"
Insert \fItext\fR at the end of the file list\. As a convenience, all
occurrences of the \fB\en\fR character sequence in \fItext\fR are replaced
with new lines\.
.IP "\fB--file-list-delim\fR \fItext\fR"
Delimit file names written to the file list with \fItext\fR instead of new
lines\. As a convenience, all occurrences of the \fB\en\fR character sequence
in \fItext\fR are replaced with new lines\.
.\"
.\" C++/Hybrid options.
.\"
.SS cxx-hybrid command options
.IP "\fB--generate-parser\fR"
Generate XML parsing code\.
.IP "\fB--generate-serializer\fR"
Generate XML serialization code\.
.IP "\fB--generate-aggregate\fR"
Generate parser/serializer aggregates for root elements and/or types\. See
also the \fB--root-element-*\fR and \fB--root-type\fR options\.
.IP "\fB--suppress-validation\fR"
Suppress the generation of validation code in parser and serializer\.
.IP "\fB--suppress-parser-val\fR"
Suppress the generation of validation code in parser\.
.IP "\fB--suppress-serializer-val\fR"
Suppress the generation of validation code in serializer\.
.IP "\fB--omit-default-attributes\fR"
Omit attributes with default and fixed values from serialized XML documents\.
.IP "\fB--suppress-enum\fR"
Suppress the generation of the XML Schema enumeration to C++ \fBenum\fR
mapping\.
.IP "\fB--generate-clone\fR"
Generate clone functions for variable-length types\. These functions allow you
to make dynamically-allocated copies of variable-length objects\.
.IP "\fB--generate-detach\fR"
Generate detach functions for elements and attributes of variable-length
types\. These functions, for example, allow you to move sub-trees in the
object model either within the same tree or between different trees\.
.IP "\fB--generate-insertion\fR \fIos\fR"
Generate data representation stream insertion operators for the \fIos\fR
output stream type\. Repeat this option to specify more than one stream type\.
The special \fBCDR\fR and \fBXDR\fR arguments are recognized as ACE CDR and
Sun RPC XDR stream types and the corresponding stream wrappers provided by the
XSD/e runtime are automatically used\. For custom stream types use the
\fB--hxx-prologue*\fR options to include the necessary declarations\.
.IP "\fB--generate-extraction\fR \fIis\fR"
Generate data representation stream extraction operators for the \fIis\fR
input stream type\. Repeat this option to specify more than one stream type\.
The special \fBCDR\fR and \fBXDR\fR arguments are recognized as ACE CDR and
Sun RPC XDR stream types and the corresponding stream wrappers provided by the
XSD/e runtime are automatically used\. For custom stream types use the
\fB--hxx-prologue*\fR options to include the necessary declarations\.
.IP "\fB--generate-forward\fR"
Generate forward declaration file\.
.IP "\fB--generate-polymorphic\fR"
Generate polymorphism-aware code\. Specify this option if you use substitution
groups or \fBxsi:type\fR\. Use the \fB--polymorphic-type\fR option to specify
which type hierarchies are polymorphic\.
.IP "\fB--runtime-polymorphic\fR"
Generate non-polymorphic code that uses the runtime library configured with
polymorphism support\.
.IP "\fB--polymorphic-type\fR \fItype\fR"
Indicate that \fItype\fR is a root of a polymorphic type hierarchy\. The XSD/e
compiler can often automatically determine which types are polymorphic based
on the substitution group declarations\. However, you may need to use this
option if you are not using substitution groups or if substitution groups are
defined in another schema\. You need to specify this option when compiling
every schema file that references \fItype\fR\.
.IP "\fB--generate-typeinfo\fR"
Generate custom type information querying functions for polymorphic object
model types\. These functions can be used instead of the standard C++ RTTI
mechanism to determine object's type at runtime\.
.IP "\fB--polymorphic-schema\fR \fIfile\fR"
Indicate that \fIfile\fR contains derivations of polymorphic types that are
not otherwise visible from the schema being compiled\. This option is used to
make sure that during the generation of parser and serializer aggregates the
compiler is aware of all possible derivations of polymorphic types\. Repeat
this option to specify more than one schema file\.
.IP "\fB--reuse-style-mixin\fR"
Generate code that supports the mixin base parser/serializer implementation
reuse style\. Note that this reuse style relies on virtual inheritance and may
result in a substantial object code size increase for large vocabularies\. By
default the tiein reuse style is used\.
.IP "\fB--custom-data\fR \fItype\fR"
Add the ability to store custom data to the C++ class generated for XML Schema
type \fItype\fR\. To add custom data to a nested compositor class use the
qualified name starting from the XML Schema type containing the compositor,
for example, \fBfoo::sequence::choise1\fR\.
.IP "\fB--custom-type\fR \fImap\fR"
Use a custom type implementation instead of the generated version\. The
\fImap\fR argument is in the form
\fIname\fR[\fB=\fR[\fIflags\fR][\fB/\fR[\fItype\fR][\fB/\fR[\fIbase\fR][\fB/\fR\fIinclude\fR]]]]\fR,
where the \fIname\fR component is the XML Schema type name being customized\.
Optional \fIflags\fR allow you to specify whether the custom type is fixed or
variable-length\. The \fBf\fR flag indicates the type is fixed-length and the
\fBv\fR flag indicates the type is variable-length\. If omitted, the default
rules are used to determine the type length\. Optional \fItype\fR is a C++
type name that should be used instead\. If specified, the object model type is
defined as a \fBtypedef\fR alias for this C++ type\. Optional \fIbase\fR is a
C++ name that should be given to the generated version\. It is normally used
as a base for the custom implementation\. Optional \fIinclude\fR is the header
file that defines the custom implementation\. It is \fB#include\fR'ed into the
generated code immediately after (if \fIbase\fR is specified) or instead of
the generated version\.
.IP "\fB--custom-parser\fR \fImap\fR"
Use a custom parser implementation instead of the generated version\. The
\fImap\fR argument is in the form
\fIname\fR[\fB=\fR[\fIbase\fR][\fB/\fR\fIinclude\fR]]\fR, where the \fIname\fR
component is the XML Schema type name being customized\. Optional \fIbase\fR
is a C++ name that should be given to the generated version\. It is normally
used as a base for the custom implementation\. Optional \fIinclude\fR is the
header file that defines the custom implementation\. It is \fB#include\fR'ed
into the generated code immediately after (if \fIbase\fR is specified) or
instead of the generated version\.
.IP "\fB--custom-serializer\fR \fImap\fR"
Use a custom serializer implementation instead of the generated version\. The
\fImap\fR argument is in the form
\fIname\fR[\fB=\fR[\fIbase\fR][\fB/\fR\fIinclude\fR]]\fR, where The \fIname\fR
component is the XML Schema type name being customized\. Optional \fIbase\fR
is a C++ name that should be given to the generated version\. It is normally
used as a base for the custom implementation\. Optional \fIinclude\fR is the
header file that defines the custom implementation\. It is \fB#include\fR'ed
into the generated code immediately after (if \fIbase\fR is specified) or
instead of the generated version\.
.IP "\fB--root-element-first\fR"
Treat only the first global element as a document root\. This determines for
which elements parser and serializer aggregates are generated\. By default all
global elements are considered document roots\. See also the
\fB--generate-aggregate\fR option\.
.IP "\fB--root-element-last\fR"
Treat only the last global element as a document root\. This determines for
which elements parser and serializer aggregates are generated\. By default all
global elements are considered document roots\. See also the
\fB--generate-aggregate\fR option\.
.IP "\fB--root-element-all\fR"
Treat all global elements as document roots (the default behavior)\. This
determines for which elements parser and serializer aggregates are generated\.
By explicitly specifying this option you can suppress the warning that is
issued if more than one global element is defined\. See also the
\fB--generate-aggregate\fR option\.
.IP "\fB--root-element-none\fR"
Do not treat any global elements as document roots\. This determines for which
elements parser and serializer aggregates are generated\. By default all
global elements are considered document roots\. See also the
\fB--generate-aggregate\fR option\.
.IP "\fB--root-element\fR \fIelement\fR"
Treat only \fIelement\fR as a document root\. This determines for which
elements parser and serializer aggregates are generated\. Repeat this option
to specify more than one root element\. See also the
\fB--generate-aggregate\fR option\.
.IP "\fB--root-type\fR \fItype\fR"
Generate parser/serializer aggregate for \fItype\fR\. Repeat this option to
specify more than one type\. See also the \fB--generate-aggregate\fR option\.
.IP "\fB--pskel-type-suffix\fR \fIsuffix\fR"
Use \fIsuffix\fR instead of the default \fB_pskel\fR to construct the names of
generated parser skeletons\.
.IP "\fB--sskel-type-suffix\fR \fIsuffix\fR"
Use \fIsuffix\fR instead of the default \fB_sskel\fR to construct the names of
generated serializer skeletons\.
.IP "\fB--pskel-file-suffix\fR \fIsuffix\fR"
Use \fIsuffix\fR instead of the default \fB-pskel\fR to construct the names of
generated parser skeleton files\.
.IP "\fB--sskel-file-suffix\fR \fIsuffix\fR"
Use \fIsuffix\fR instead of the default \fB-sskel\fR to construct the names of
generated serializer skeleton files\.
.IP "\fB--pimpl-type-suffix\fR \fIsuffix\fR"
Use \fIsuffix\fR instead of the default \fB_pimpl\fR to construct the names of
generated parser implementations\.
.IP "\fB--simpl-type-suffix\fR \fIsuffix\fR"
Use \fIsuffix\fR instead of the default \fB_simpl\fR to construct the names of
generated serializer implementations\.
.IP "\fB--pimpl-file-suffix\fR \fIsuffix\fR"
Use \fIsuffix\fR instead of the default \fB-pimpl\fR to construct the names of
generated parser implementation files\.
.IP "\fB--simpl-file-suffix\fR \fIsuffix\fR"
Use \fIsuffix\fR instead of the default \fB-simpl\fR to construct the names of
generated serializer implementation files\.
.IP "\fB--paggr-type-suffix\fR \fIsuffix\fR"
Use \fIsuffix\fR instead of the default \fB_paggr\fR to construct the names of
generated parser aggregates\.
.IP "\fB--saggr-type-suffix\fR \fIsuffix\fR"
Use \fIsuffix\fR instead of the default \fB_saggr\fR to construct the names of
generated serializer aggregates\.
.\"
.\" C++/Parser options.
.\"
.SS cxx-parser command options
.IP "\fB--type-map\fR \fImapfile\fR"
Read XML Schema to C++ type mapping information from \fImapfile\fR\. Repeat
this option to specify several type maps\. Type maps are considered in order
of appearance and the first match is used\. By default all user-defined types
are mapped to \fBvoid\fR\. See the TYPE MAP section below for more
information\.
.IP "\fB--suppress-validation\fR"
Suppress the generation of validation code\.
.IP "\fB--reuse-style-mixin\fR"
Generate code that supports the mixin base parser implementation reuse style\.
Note that this reuse style relies on virtual inheritance and may result in a
substantial object code size increase for large vocabularies\. By default
support for the tiein style is generated\.
.IP "\fB--reuse-style-none\fR"
Do not generate any support for base parser implementation reuse\. By default
support for the tiein style is generated\.
.IP "\fB--generate-polymorphic\fR"
Generate polymorphism-aware code\. Specify this option if you use substitution
groups or \fBxsi:type\fR\.
.IP "\fB--runtime-polymorphic\fR"
Generate non-polymorphic code that uses the runtime library configured with
polymorphism support\.
.IP "\fB--generate-noop-impl\fR"
Generate a sample parser implementation that does nothing (no operation)\. The
sample implementation can then be filled with the application-specific code\.
For an input file in the form \fBname\.xsd\fR this option triggers the
generation of the two additional C++ files in the form: \fBname-pimpl\.hxx\fR
(parser implementation header file) and \fBname-pimpl\.cxx\fR (parser
implementation source file)\.
.IP "\fB--generate-print-impl\fR"
Generate a sample parser implementation that prints the XML data to
STDOUT\fR\. For an input file in the form \fBname\.xsd\fR this option triggers
the generation of the two additional C++ files in the form:
\fBname-pimpl\.hxx\fR (parser implementation header file) and
\fBname-pimpl\.cxx\fR (parser implementation source file)\.
.IP "\fB--generate-test-driver\fR"
Generate a test driver for the sample parser implementation\. For an input
file in the form \fBname\.xsd\fR this option triggers the generation of an
additional C++ file in the form \fBname-pdriver\.cxx\fR\.
.IP "\fB--force-overwrite\fR"
Force overwriting of the existing implementation and test driver files\. Use
this option only if you do not mind loosing the changes you have made in the
sample implementation or test driver files\.
.IP "\fB--root-element-first\fR"
Indicate that the first global element is the document root\. This information
is used to generate the test driver for the sample implementation\.
.IP "\fB--root-element-last\fR"
Indicate that the last global element is the document root\. This information
is used to generate the test driver for the sample implementation\.
.IP "\fB--root-element\fR \fIelement\fR"
Indicate that \fIelement\fR is the document root\. This information is used to
generate the test driver for the sample implementation\.
.IP "\fB--skel-type-suffix\fR \fIsuffix\fR"
Use the provided \fIsuffix\fR instead of the default \fB_pskel\fR to construct
the names of generated parser skeletons\.
.IP "\fB--skel-file-suffix\fR \fIsuffix\fR"
Use the provided \fIsuffix\fR instead of the default \fB-pskel\fR to construct
the names of generated parser skeleton files\.
.IP "\fB--impl-type-suffix\fR \fIsuffix\fR"
Use the provided \fIsuffix\fR instead of the default \fB_pimpl\fR to construct
the names of parser implementations for the built-in XML Schema types and
sample parser implementations\.
.IP "\fB--impl-file-suffix\fR \fIsuffix\fR"
Use the provided \fIsuffix\fR instead of the default \fB-pimpl\fR to construct
the names of generated sample parser implementation files\.
.\"
.\" C++/Serializer options.
.\"
.SS cxx-serializer command options
.IP "\fB--type-map\fR \fImapfile\fR"
Read XML Schema to C++ type mapping information from \fImapfile\fR\. Repeat
this option to specify several type maps\. Type maps are considered in order
of appearance and the first match is used\. By default all user-defined types
are mapped to \fBvoid\fR\. See the TYPE MAP section below for more
information\.
.IP "\fB--suppress-validation\fR"
Suppress the generation of validation code\.
.IP "\fB--reuse-style-mixin\fR"
Generate code that supports the mixin base serializer implementation reuse
style\. Note that this reuse style relies on virtual inheritance and may
result in a substantial object code size increase for large vocabularies\. By
default support for the tiein style is generated\.
.IP "\fB--reuse-style-none\fR"
Do not generate any support for base serializer implementation reuse\. By
default support for the tiein style is generated\.
.IP "\fB--generate-polymorphic\fR"
Generate polymorphism-aware code\. Specify this option if you use substitution
groups or \fBxsi:type\fR\.
.IP "\fB--runtime-polymorphic\fR"
Generate non-polymorphic code that uses the runtime library configured with
polymorphism support\.
.IP "\fB--generate-empty-impl\fR"
Generate a sample serializer implementation with empty function bodies which
can then be filled with the application-specific code\. For an input file in
the form \fBname\.xsd\fR this option triggers the generation of the two
additional C++ files in the form: \fBname-simpl\.hxx\fR (serializer
implementation header file) and \fBname-simpl\.cxx\fR (serializer
implementation source file)\.
.IP "\fB--generate-test-driver\fR"
Generate a test driver for the sample serializer implementation\. For an input
file in the form \fBname\.xsd\fR this option triggers the generation of an
additional C++ file in the form \fBname-sdriver\.cxx\fR\.
.IP "\fB--force-overwrite\fR"
Force overwriting of the existing implementation and test driver files\. Use
this option only if you do not mind loosing the changes you have made in the
sample implementation or test driver files\.
.IP "\fB--root-element-first\fR"
Indicate that the first global element is the document root\. This information
is used to generate the test driver for the sample implementation\.
.IP "\fB--root-element-last\fR"
Indicate that the last global element is the document root\. This information
is used to generate the test driver for the sample implementation\.
.IP "\fB--root-element\fR \fIelement\fR"
Indicate that \fIelement\fR is the document root\. This information is used to
generate the test driver for the sample implementation\.
.IP "\fB--skel-type-suffix\fR \fIsuffix\fR"
Use the provided \fIsuffix\fR instead of the default \fB_sskel\fR to construct
the names of generated serializer skeletons\.
.IP "\fB--skel-file-suffix\fR \fIsuffix\fR"
Use the provided \fIsuffix\fR instead of the default \fB-sskel\fR to construct
the names of generated serializer skeleton files\.
.IP "\fB--impl-type-suffix\fR \fIsuffix\fR"
Use the provided \fIsuffix\fR instead of the default \fB_simpl\fR to construct
the names of serializer implementations for the built-in XML Schema types and
sample serializer implementations\.
.IP "\fB--impl-file-suffix\fR \fIsuffix\fR"
Use the provided \fIsuffix\fR instead of the default \fB-simpl\fR to construct
the names of generated sample serializer implementation files\.
.\"
.\" Type map
.\"
.SH TYPE MAP

Type map files are used to define a mapping between XML Schema and
C++ types. For C++/Parser, the compiler uses this information to
determine the return types of
.B post_*
functions in parser skeletons corresponding to XML Schema types as
well as argument types for callbacks corresponding to elements and
attributes of these types. For C++/Serializer, type maps are used
to determine the argument type of
.B pre
functions in serializer skeletons corresponding to XML Schema types
as well as return types for callbacks corresponding to elements and
attributes of these types.

The compiler has a set of predefined mapping rules that map the
built-in XML Schema types to suitable C++ types (discussed in
the following sub-sections) and all other types to
.BR void .
By providing your own type maps you can override these predefined
rules. The format of the type map file is presented below:


.RS
.B namespace
.I schema-namespace
[
.I cxx-namespace
]
.br
.B {
.br
  (
.B include
.IB file-name ;
)*
.br
  ([
.B type
]
.I schema-type cxx-ret-type
[
.I cxx-arg-type
.RB ] ;
)*
.br
.B }
.br
.RE

Both
.I schema-namespace
and
.I schema-type
are regex patterns while
.IR cxx-namespace ,
.IR cxx-ret-type ,
and
.I cxx-arg-type
are regex pattern substitutions. All names can be optionally enclosed
in \fR" "\fR, for example, to include white-spaces.

.I schema-namespace
determines XML Schema namespace. Optional
.I cxx-namespace
is prefixed to every C++ type name in this namespace declaration.
.I cxx-ret-type
is a C++ type name that is used as a return type for the
.B post_*
function in C++/Parser or for element/attribute callbacks in C++/Serializer.
Optional
.I cxx-arg-type
is an argument type for element/attribute callbacks in C++/Parser or for the
.B pre
function in C++/Serializer. If
.I cxx-arg-type
is not specified, it defaults to
.I cxx-ret-type
if
.I cxx-ret-type
ends with
.B *
or
.B &
(that is, it is a pointer or a reference) and
.B const
\fIcxx-ret-type\fB&\fR otherwise.
.I file-name
is a file name either in the \fR" "\fR or < > format and is added with the
.B #include
directive to the generated code.

The \fB#\fR character starts a comment that ends with a new line or end of
file. To specify a name that contains \fB#\fR enclose it in \fR" "\fR. For
example:

.RS
namespace http://www.example.com/xmlns/my my
.br
{
.br
  include "my.hxx";
.br

  # Pass apples by value.
  #
  apple apple;
.br

  # Pass oranges as pointers.
  #
  orange orange_t*;
.br
}
.br
.RE

In the example above, for the
.B http://www.example.com/xmlns/my#orange
XML Schema type, the
.B my::orange_t*
C++ type will be used as both return and argument types.

Several namespace declarations can be specified in a single file.
The namespace declaration can also be completely omitted to map
types in a schema without a namespace. For instance:

.RS
include "my.hxx";
.br
apple apple;
.br

namespace http://www.example.com/xmlns/my
.br
{
.br
  orange "const orange_t*";
.br
}
.br
.RE

The compiler has a number of predefined mapping rules for the built-in
XML Schema types that vary depending on the mapping used. They are
described in the following subsections. The last predefined rule
for all the mappings maps anything that wasn't mapped by previous rules to
.BR void :

.RS
namespace .*
.br
{
.br
  .* void void;
.br
}
.br
.RE

When you provide your own type maps with the
.B --type-map
option, they are evaluated first. This allows you to selectively override
predefined rules.

.\"
.\" Predefined C++/Parser Type Maps
.\"
.SS Predefined C++/Parser Type Maps

The C++/Parser mapping provides a number of predefined type map rules
for the built-in XML Schema types. They can be presented as the
following map files:

.RS
namespace http://www.w3.org/2001/XMLSchema
.br
{
.br
  boolean bool bool;
.br

  byte "signed char" "signed char";
.br
  unsignedByte "unsigned char" "unsigned char";
.br

  short short short;
.br
  unsignedShort "unsigned short" "unsigned short";
.br

  int int int;
.br
  unsignedInt "unsigned int" "unsigned int";
.br

  long "long long" "long long";
.br
  unsignedLong "unsigned long long" "unsigned long long";
.br

  integer long long;
.br

  negativeInteger long long;
.br
  nonPositiveInteger long long;
.br

  positiveInteger "unsigned long" "unsigned long";
.br
  nonNegativeInteger "unsigned long" "unsigned long";
.br

  float float float;
.br
  double double double;
.br
  decimal double double;
.br

  NMTOKENS xml_schema::string_sequence*;
.br
  IDREFS xml_schema::string_sequence*;
.br

  base64Binary xml_schema::buffer*;
.br
  hexBinary xml_schema::buffer*;
.br

  date xml_schema::date;
.br
  dateTime xml_schema::date_time;
.br
  duration xml_schema::duration;
.br
  gDay xml_schema::gday;
.br
  gMonth xml_schema::gmonth;
.br
  gMonthDay xml_schema::gmonth_day;
.br
  gYear xml_schema::gyear;
.br
  gYearMonth xml_schema::gyear_month;
.br
  time xml_schema::time;
.br
}
.br
.RE

If the
.B --no-stl
option is not specified, the following mapping is used for the
string-based XML Schema built-in types:

.RS
namespace http://www.w3.org/2001/XMLSchema
.br
{
.br
  include <string>;
.br

  string std::string;
.br
  normalizedString std::string;
.br
  token std::string;
.br
  Name std::string;
.br
  NMTOKEN std::string;
.br
  NCName std::string;
.br
  ID std::string;
.br
  IDREF std::string;
.br
  language std::string;
.br
  anyURI std::string;
.br

  QName xml_schema::qname;
.br
}
.br
.RE

Otherwise, a C string-based mapping is used:

.RS
namespace http://www.w3.org/2001/XMLSchema
.br
{
.br
  string char*;
.br
  normalizedString char*;
.br
  token char*;
.br
  Name char*;
.br
  NMTOKEN char*;
.br
  NCName char*;
.br
  ID char*;
.br
  IDREF char*;
.br
  language char*;
.br
  anyURI char*;
.br

  QName xml_schema::qname*;
.br
}
.br
.RE

.\"
.\" Predefined C++/Serializer Type Maps
.\"
.SS Predefined C++/Serializer Type Maps

The C++/Serializer mapping provides a number of predefined type map
rules for the built-in XML Schema types. They can be presented as the
following map files:

.RS
namespace http://www.w3.org/2001/XMLSchema
.br
{
.br
  boolean bool bool;
.br

  byte "signed char" "signed char";
.br
  unsignedByte "unsigned char" "unsigned char";
.br

  short short short;
.br
  unsignedShort "unsigned short" "unsigned short";
.br

  int int int;
.br
  unsignedInt "unsigned int" "unsigned int";
.br

  long "long long" "long long";
.br
  unsignedLong "unsigned long long" "unsigned long long";
.br

  integer long long;
.br

  negativeInteger long long;
.br
  nonPositiveInteger long long;
.br

  positiveInteger "unsigned long" "unsigned long";
.br
  nonNegativeInteger "unsigned long" "unsigned long";
.br

  float float float;
.br
  double double double;
.br
  decimal double double;
.br

  NMTOKENS "const xml_schema::string_sequence*";
.br
  IDREFS "const xml_schema::string_sequence*";
.br

  base64Binary "const xml_schema::buffer*";
.br
  hexBinary "const xml_schema::buffer*";
.br

  date xml_schema::date;
.br
  dateTime xml_schema::date_time;
.br
  duration xml_schema::duration;
.br
  gDay xml_schema::gday;
.br
  gMonth xml_schema::gmonth;
.br
  gMonthDay xml_schema::gmonth_day;
.br
  gYear xml_schema::gyear;
.br
  gYearMonth xml_schema::gyear_month;
.br
  time xml_schema::time;
.br
}
.br
.RE

If the
.B --no-stl
option is not specified, the following mapping is used for the
string-based XML Schema built-in types:

.RS
namespace http://www.w3.org/2001/XMLSchema
.br
{
.br
  include <string>;
.br

  string std::string;
.br
  normalizedString std::string;
.br
  token std::string;
.br
  Name std::string;
.br
  NMTOKEN std::string;
.br
  NCName std::string;
.br
  ID std::string;
.br
  IDREF std::string;
.br
  language std::string;
.br
  anyURI std::string;
.br

  QName xml_schema::qname;
.br
}
.br
.RE

Otherwise, a C string-based mapping is used:

.RS
namespace http://www.w3.org/2001/XMLSchema
.br
{
.br
  string "const char*";
.br
  normalizedString "const char*";
.br
  token "const char*";
.br
  Name "const char*";
.br
  NMTOKEN "const char*";
.br
  NCName "const char*";
.br
  ID "const char*";
.br
  IDREF "const char*";
.br
  language "const char*";
.br
  anyURI "const char*";
.br

  QName "const xml_schema::qname*";
.br
}
.br
.RE

.\"
.\" REGEX AND SHELL QUOTING
.\"
.SH REGEX AND SHELL QUOTING
When entering a regular expression argument in the shell command line
it is often necessary to use quoting (enclosing the argument in " "
or ' ') in order to prevent the shell from interpreting certain
characters, for example, spaces as argument separators and $ as
variable expansions.

Unfortunately it is hard to achieve this in a manner that is portable
across POSIX shells, such as those found on GNU/Linux and UNIX, and
Windows shell. For example, if you use " " for quoting you will get
a wrong result with POSIX shells if your expression contains $. The
standard way of dealing with this on POSIX systems is to use ' '
instead. Unfortunately, Windows shell does not remove ' '  from
arguments when they are passed to applications. As a result you may
have to use ' ' for POSIX and " " for Windows ($ is not treated as
a special character on Windows).

Alternatively, you can save regular expression options into a file,
one option per line, and use this file with the
.B --options-file
option. With this approach you don't need to worry about shell quoting.

.\"
.\" DIAGNOSTICS
.\"
.SH DIAGNOSTICS
If the input file is not a valid W3C XML Schema definition,
.B xsde
will issue diagnostic messages to
.B STDERR
and exit with non-zero exit code.

.SH BUGS
Send bug reports to the xsde-users@codesynthesis.com mailing list.

.SH COPYRIGHT
Copyright (c) 2009-2024 Code Synthesis Tools CC.

Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License,
version 1.2; with no Invariant Sections, no Front-Cover Texts and
no Back-Cover Texts. Copy of the license can be obtained from
http://codesynthesis.com/licenses/fdl-1.2.txt
